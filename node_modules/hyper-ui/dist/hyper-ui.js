const _document = document, _Object = Object, _Array = Array, _Symbol = Symbol, _Boolean = Boolean, _Map = Map, _Node = Node, _console = console, { assign: _assign, is: _is, keys: _keys } = _Object, { isArray: _isArray, from: _from } = _Array, { splice: _splice, push: _push, indexOf: _indexOf } = _Array.prototype, _undefined = undefined, _null = null, _Infinity = Infinity;

const registry = new _Map();
const define = function (name, desc) {
    const type = _Symbol(name);
    registry.set(type, desc);
    return type;
};

const toArr = (a) => (_isArray(a) ? a : [a]);
const toFrag = (nodes) => nodes.reduce((frag, node) => (frag.appendChild(node), frag), _document.createDocumentFragment());
const isHNode = (value) => value && typeof value === 'object' && value.isHNode;
const replaceNodes = function (ownerNode, oldNodes, newNodes) {
    oldNodes.forEach((oldNode, i) => {
        if (i) {
            ownerNode.removeChild(oldNode);
        }
        else {
            ownerNode.replaceChild(toFrag(newNodes), oldNode);
        }
    });
};
const inherit = function (target, source) {
    target.nodes = source.nodes;
    target.owner = source.owner;
    target.ownerNode = source.ownerNode;
    target.context = source.context;
    target.store = source.store;
    if (source.desc) {
        target.output = source.output;
    }
    else {
        target.events = source.events;
    }
};

const renderCallbacks = new Array();
const render = function (src, options = {}) {
    const { parent = _document.body, context = createStore(), clear, owner } = options;
    if (options.sync) {
        if (clear) {
            _from(parent.childNodes).forEach(childNode => {
                parent.removeChild(childNode);
            });
        }
        parent.appendChild(toFrag(toNodes(src, context, parent, owner)));
    }
    else {
        renderCallbacks.push(() => {
            render(src, { parent, owner, context, clear, sync: true });
        });
        reqTick();
    }
};

const noCmpProps = ['children'];
function patch(node, hNode, curProps, oldProps, curPropKeys) {
    let curProp, oldProp;
    curPropKeys.forEach(key => {
        curProp = curProps[key];
        oldProp = oldProps[key];
        if (noCmpProps.includes(key) || !HUI.cmp(curProp, oldProp)) {
            handleProp(node, hNode, key, curProp, oldProp);
        }
    });
}

const clear = function (hNode) {
    const { desc, output } = hNode;
    hNode.active = false;
    if (desc) {
        if (desc.clear) {
            try {
                desc.clear.call(hNode, hNode.props, hNode.store, hNode.context);
            }
            catch (err) {
                _console.error(err);
            }
        }
    }
    else {
        const { ref } = hNode.props;
        if (ref) {
            ref();
        }
    }
    const index = expired.indexOf(hNode);
    if (~index) {
        expired.splice(index, 1);
    }
    if (output) {
        output.forEach((child) => {
            if (isHNode(child)) {
                clear(child);
            }
        });
    }
};

const updateChildren = function (element, hNode, newChildren, oldChildren) {
    const { childNodes } = element, oldChildrenCount = oldChildren.length;
    let nodeOffset = 0, oldProps, oldNodes, newChild, newNodes, newProps, newPropKeys;
    oldChildren.forEach((oldChild, i) => {
        newChild = newChildren[i];
        if (newChild) {
            if (isHNode(oldChild)) {
                oldNodes = oldChild.nodes;
                if (isHNode(newChild) && newChild.type === oldChild.type) {
                    newNodes = oldNodes;
                    if (oldChild.desc) {
                        inherit(newChild, oldChild);
                        nodeOffset += newNodes.length;
                        return mark(newChild);
                    }
                    else {
                        newPropKeys = _keys(newProps = newChild.props);
                        if (_keys(oldProps = oldChild.props).every(key => newPropKeys.includes(key))) {
                            inherit(newChild, oldChild);
                            nodeOffset++;
                            return patch(newNodes[0], newChild, newProps, oldProps, newPropKeys);
                        }
                    }
                }
                clear(oldChild);
            }
            else if (HUI.cmp(oldChild, newChild)) {
                return nodeOffset++;
            }
            else {
                oldNodes = childNodes.length ? [childNodes[nodeOffset]] : [];
            }
            nodeOffset += (newNodes = toNodes(newChild, hNode.context, element, hNode)).length;
            if (oldNodes.length) {
                replaceNodes(element, oldNodes, newNodes);
            }
            else {
                element.appendChild(toFrag(newNodes));
            }
        }
        else {
            if (isHNode(oldChild)) {
                clear(oldChild);
                oldChild.nodes.forEach(node => {
                    element.removeChild(node);
                });
            }
            else if (childNodes.length) {
                element.removeChild(childNodes[nodeOffset++]);
            }
        }
    });
    if (oldChildrenCount < newChildren.length) {
        render(newChildren.slice(oldChildrenCount), {
            parent: element,
            owner: hNode,
            context: hNode.context
        });
    }
};

const propHandlers = new _Map([
    ['children', function (element, newChildren, oldChildren, hNode) {
            updateChildren(element, hNode, newChildren, oldChildren || []);
        }],
    ['style', function (element, style) {
            if (style && typeof style === 'object') {
                _assign(element.style, style);
            }
            else {
                try {
                    element.style = style;
                }
                catch {
                    element.setAttribute('style', style);
                }
            }
        }],
    ['class', function (element, classes) {
            element.setAttribute('class', _isArray(classes) ?
                classes.filter(_Boolean).join(' ') :
                classes);
        }],
    ['ref', function (element, callback) {
            callback(element);
        }],
    ['attr', function (element, attributes) {
            _keys(attributes).forEach(key => {
                element.setAttribute(key, attributes[key]);
            });
        }],
    ['prop', function (element, properties) {
            _assign(element, properties);
        }]
]);

const LISTENER_PREFIX = 'on';
const CAPTURE = 'Captrue', NONPASSIVE = 'Nonpassive', ONCE = 'Once';
const listen = function (node, event, listener) {
    let capture = false, passive = true, once = false;
    for (let i = 0; i < 3; i++) {
        if (event.endsWith(CAPTURE)) {
            capture = true;
            event = event.slice(0, -7);
        }
        else if (event.endsWith(NONPASSIVE)) {
            passive = false;
            event = event.slice(0, -10);
        }
        else if (event.endsWith(ONCE)) {
            once = true;
            event = event.slice(0, -4);
        }
    }
    const options = (capture || !passive || once) && { capture, passive, once };
    node.addEventListener(event, listener, options);
    return [event, listener, options];
};

const handleProp = function (element, hNode, key, newValue, oldValue) {
    const handler = propHandlers.get(key);
    if (handler) {
        handler(element, newValue, oldValue, hNode);
    }
    else {
        if (key.startsWith(LISTENER_PREFIX)) {
            const { events } = hNode, record = events.get(key);
            if (record) {
                element.removeEventListener(record[0], record[1], record[2]);
            }
            events.set(key, listen(element, key.slice(2), newValue));
        }
        else if (key in element) {
            try {
                element[key] = newValue;
            }
            catch {
                element.setAttribute(key, newValue);
            }
        }
        else {
            element.setAttribute(key, newValue);
        }
    }
};

const handleError = function (err, hNode) {
    let { owner } = hNode, desc;
    if (owner) {
        while (!((desc = owner.desc) && desc.catch) && owner.owner) {
            owner = owner.owner;
        }
        owner.error = err;
        mark(owner);
    }
    else {
        throw err;
    }
};

const toNodes = function (src, context, ownerNode, owner) {
    const srcType = typeof src;
    if (srcType === 'string') {
        return [_document.createTextNode(src)];
    }
    else if (srcType === 'number') {
        return [_document.createTextNode(String(src))];
    }
    if (src) {
        if (_isArray(src) && src.length) {
            return src.flat(_Infinity).map(s => toNodes(s, context, ownerNode, owner)).flat();
        }
        else if (isHNode(src)) {
            const { type, desc, props } = src;
            src.ownerNode = ownerNode;
            src.owner = owner;
            if (desc) {
                const store = src.store = createStore();
                if (desc.state) {
                    src.store.bind(src, desc.state);
                }
                src.context = context;
                if (desc.context) {
                    context.bind(src, desc.context);
                }
                try {
                    src.active = false;
                    if (desc.init) {
                        desc.init.call(src, props, store, context);
                    }
                    return src.nodes = toNodes(src.output = toArr(desc.render.call(src, props, store, context)).flat(_Infinity), context, ownerNode, src);
                }
                catch (err) {
                    if (desc.catch) {
                        return src.nodes = toNodes(src.output = toArr(desc.catch.call(src, err, props, store, context)).flat(_Infinity), context, ownerNode, src);
                    }
                    else {
                        handleError(err, src);
                    }
                }
                finally {
                    src.active = true;
                }
            }
            else {
                src.events = new _Map();
                const node = props.xmlns ?
                    _document.createElementNS(props.xmlns, type) :
                    _document.createElement(type);
                _keys(props).forEach(key => {
                    handleProp(node, src, key, props[key]);
                });
                src.output = [];
                src.nodes = [node];
                return [node];
            }
        }
    }
    return [_document.createTextNode('')];
};

const updateComponent = function (hNode) {
    const { desc, output, nodes, owner, ownerNode, context, props, store, error } = hNode, outputLength = output.length, ownerNodes = owner && owner.nodes;
    let newNodes = [].concat(nodes);
    try {
        hNode.active = false;
        if (error) {
            hNode.error = _undefined;
            throw error;
        }
        const ownerNodeNodes = ownerNode.childNodes;
        let old, oldProps, oldNodes, oldNodesLength, curNodes, curProps, curPropKeys, nodeOffset = 0, nextNode;
        (hNode.output = toArr(desc.render.call(hNode, props, store, context)).flat(_Infinity)).forEach((cur, i) => {
            if (i < outputLength) {
                old = output[i];
                oldNodesLength = 1;
                if (isHNode(old)) {
                    oldNodesLength = (oldNodes = old.nodes).length;
                    if (isHNode(cur) && old.type === cur.type) {
                        if (old.desc) {
                            inherit(cur, old);
                            mark(cur);
                            nodeOffset += cur.nodes.length;
                            return;
                        }
                        else {
                            curPropKeys = _keys(curProps = cur.props);
                            if (_keys(oldProps = old.props).every(k => curPropKeys.includes(k))) {
                                nodeOffset++;
                                inherit(cur, old);
                                return patch(oldNodes[0], cur, curProps, oldProps, curPropKeys);
                            }
                        }
                    }
                    clear(old);
                }
                else if (!isHNode(cur) && HUI.cmp(old, cur)) {
                    return;
                }
                curNodes = toNodes(cur, context, ownerNode, hNode);
                oldNodes = _splice.apply(newNodes, [newNodes.indexOf(nodes[nodeOffset]), oldNodesLength]
                    .concat(curNodes));
                nodeOffset += oldNodesLength;
                replaceNodes(ownerNode, oldNodes, curNodes);
            }
            else {
                if (i === outputLength) {
                    nextNode =
                        ownerNodeNodes[_indexOf.call(ownerNodeNodes, newNodes[newNodes.length - 1]) + 1] ||
                            _null;
                }
                _push.apply(newNodes, curNodes = toNodes(cur, context, ownerNode, hNode));
                ownerNode.insertBefore(toFrag(curNodes), nextNode);
            }
        });
    }
    catch (err) {
        if (desc.catch) {
            newNodes = toNodes(hNode.output = toArr(desc.catch.call(hNode, err, props, store, context)), context, ownerNode, hNode);
            replaceNodes(ownerNode, nodes, newNodes);
            output.forEach(child => {
                if (isHNode(child)) {
                    clear(child);
                }
            });
        }
        else {
            handleError(err, hNode);
        }
    }
    finally {
        hNode.active = true;
    }
    if (ownerNodes) {
        const firstNode = nodes[0], restArgs = [nodes.length].concat(newNodes);
        let target = owner, targetNodes = ownerNodes;
        while (target) {
            targetNodes = target.nodes;
            _splice.apply(targetNodes, [targetNodes.indexOf(firstNode)].concat(restArgs));
            target = target.owner;
        }
    }
    hNode.nodes = newNodes;
};

const expired = new Array();
const deferCallbacks = new Array(), preDeferCallbacks = new Array();
let willTick = false;
const ticker = function () {
    willTick = false;
    const deadline = Date.now() + HUI.frameLimit;
    let cur, i;
    for (i = 0; i < expired.length; i++) {
        cur = expired[i];
        if (!cur) {
            continue;
        }
        expired[i] = _undefined;
        try {
            updateComponent(cur);
        }
        catch (err) {
            expired.splice(0, i + 1);
            throw err;
        }
        if (Date.now() >= deadline) {
            expired.splice(0, i + 1);
            return tick();
        }
    }
    expired.length = 0;
    for (i = 0; i < preDeferCallbacks.length; i++) {
        preDeferCallbacks[i]();
        if (Date.now() >= deadline) {
            preDeferCallbacks.splice(0, i + 1);
            return tick();
        }
    }
    preDeferCallbacks.length = 0;
    for (i = 0; i < renderCallbacks.length; i++) {
        renderCallbacks[i]();
        if (Date.now() >= deadline) {
            renderCallbacks.splice(0, i + 1);
            return tick();
        }
    }
    renderCallbacks.length = 0;
    for (i = 0; i < deferCallbacks.length; i++) {
        deferCallbacks[i]();
        if (Date.now() >= deadline) {
            deferCallbacks.splice(0, i + 1);
            return tick();
        }
    }
    deferCallbacks.length = 0;
};
const tick = function () {
    HUI.tick(ticker);
    willTick = true;
};
const reqTick = function () {
    if (!willTick) {
        tick();
    }
};
const mark = function (hNode) {
    if (!expired.includes(hNode)) {
        reqTick();
        expired.push(hNode);
    }
};
const defer = function (callback, ...args) {
    deferCallbacks.push(function () {
        callback(...args);
    });
    reqTick();
};

const createStore = function () {
    const map = new _Map(), bindingMap = new _Map(), setterMap = new _Map();
    const store = {
        map,
        bind(hNode, subscriptions) {
            subscriptions.forEach(key => {
                if (bindingMap.has(key)) {
                    bindingMap.get(key).push(hNode);
                }
                else {
                    bindingMap.set(key, [hNode]);
                }
            });
            return this;
        },
        get: function store_get(key) {
            return map.get(key);
        },
        set: function store_set(key, value, force) {
            if (force || !HUI.cmp(value, store.get(key))) {
                map.set(key, value);
                if (bindingMap.has(key)) {
                    bindingMap.get(key).forEach(hNode => {
                        if (hNode.active) {
                            mark(hNode);
                        }
                    });
                }
            }
            return store;
        },
        setter: function store_setter(key, force) {
            const index = +!force;
            if (setterMap.has(key)) {
                const setters = setterMap.get(key), setter = setters[index];
                if (setter) {
                    return setter;
                }
                else {
                    return setters[index] = function setter(value) {
                        store.set(key, value, force);
                    };
                }
            }
            else {
                const setters = new Array();
                setterMap.set(key, setters);
                return setters[index] = function setter(value) {
                    store.set(key, value, force);
                };
            }
        },
        toggle: function store_toggle(key) {
            return store.set(key, !store.get(key));
        },
        inc: function store_inc(key, addition = 1) {
            return store.set(key, store.get(key) + addition);
        },
        push: function store_push(key, ...items) {
            return store.set(key, store.get(key).concat(items));
        },
        unshift: function store_unshift(key, ...items) {
            return store.set(key, items.concat(store.get(key)));
        },
        slice: function store_slice(key, start, end) {
            return store.set(key, store.get(key).slice(start, end));
        },
        splice: function store_splice(key, start, deleteCount, ...items) {
            const arr = store.get(key).slice();
            _splice.apply(arr, [start, deleteCount].concat(items));
            return store.set(key, arr);
        }
    };
    return store;
};

const portalSymbol = define('HUI.Portal', {
    init: function portal_init(props, store) {
        store.set('parent', props.parent || _document.body);
        store.set('fragment', HUI(HUI.Fragment, _null, props.children));
    },
    render: function portal_render(props, store, context) {
        render(store.get('fragment'), {
            parent: store.get('parent'),
            owner: this,
            context
        });
    },
    clear: function portal_clear(props, store) {
        const fragment = store.get('fragment'), { ownerNode, nodes } = fragment;
        clear(fragment);
        nodes.forEach(node => {
            ownerNode.removeChild(node);
        });
        nodes.length = 0;
    }
});

const contextSymbol = define('HUI.Context', {
    init: function context_init(props, store, context) {
        context.set(props.key, props.value);
    },
    render: function context_render(props) {
        return props.children;
    }
});

const cmp = function (a, b) {
    if (_is(a, b)) {
        return true;
    }
    if (_isArray(a)) {
        return _isArray(b) &&
            a.length === b.length &&
            a.every((v, i) => cmp(b[i], v));
    }
    if (a && b && typeof a === 'object' && typeof b === 'object') {
        if (a.isHNode) {
            return b.isHNode &&
                a.type === b.type &&
                cmp(a.props, b.props);
        }
        else if (!(a instanceof _Node || b instanceof _Node)) {
            const keysA = _keys(a), keysB = _keys(b);
            return keysA.length === keysB.length &&
                keysA.every(k => keysB.includes(k) && cmp(a[k], b[k]));
        }
    }
    return false;
};

const fragmentSymbol = define('HUI.Fragment', {
    render: function fragment_render(props) {
        return props.children;
    }
});

const HUI = (type, props, ...children) => ({
    isHNode: true,
    type,
    desc: registry.get(type),
    props: _assign({ children: children.flat(_Infinity) }, props),
    active: true
});
HUI.registry = registry;
HUI.define = define;
HUI.createStore = createStore;
HUI.propHandlers = propHandlers;
HUI.noCmpProps = noCmpProps;
HUI.render = render;
HUI.tick = function (callback) { requestAnimationFrame(callback); };
HUI.frameLimit = 15;
HUI.defer = defer;
HUI.Portal = portalSymbol;
HUI.Context = contextSymbol;
HUI.Fragment = fragmentSymbol;
HUI.cmp = cmp;

export default HUI;
