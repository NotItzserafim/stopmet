(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    (global = global || self, global.HUI = factory());
}(this, function () { 'use strict';

    var _document = document,
        _Object = Object,
        _Array = Array,
        _Symbol = Symbol,
        _Boolean = Boolean,
        _Map = Map,
        _Node = Node,
        _console = console,
        _assign = _Object.assign,
        _is = _Object.is,
        _keys = _Object.keys,
        _isArray = _Array.isArray,
        _from = _Array.from,
        _Array$prototype = _Array.prototype,
        _splice = _Array$prototype.splice,
        _push = _Array$prototype.push,
        _indexOf = _Array$prototype.indexOf,
        _undefined = undefined,
        _null = null,
        _Infinity = Infinity;

    var registry = new _Map();
    var define = function define(name, desc) {
      var type = _Symbol(name);

      registry.set(type, desc);
      return type;
    };

    function _typeof(obj) {
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function (obj) {
          return typeof obj;
        };
      } else {
        _typeof = function (obj) {
          return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
      }

      return _typeof(obj);
    }

    var toArr = function toArr(a) {
      return _isArray(a) ? a : [a];
    };
    var toFrag = function toFrag(nodes) {
      return nodes.reduce(function (frag, node) {
        return frag.appendChild(node), frag;
      }, _document.createDocumentFragment());
    };
    var isHNode = function isHNode(value) {
      return value && _typeof(value) === 'object' && value.isHNode;
    };
    var replaceNodes = function replaceNodes(ownerNode, oldNodes, newNodes) {
      oldNodes.forEach(function (oldNode, i) {
        if (i) {
          ownerNode.removeChild(oldNode);
        } else {
          ownerNode.replaceChild(toFrag(newNodes), oldNode);
        }
      });
    };
    var inherit = function inherit(target, source) {
      target.nodes = source.nodes;
      target.owner = source.owner;
      target.ownerNode = source.ownerNode;
      target.context = source.context;
      target.store = source.store;

      if (source.desc) {
        target.output = source.output;
      } else {
        target.events = source.events;
      }
    };

    var renderCallbacks = new Array();
    var render = function render(src) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var _options$parent = options.parent,
          parent = _options$parent === void 0 ? _document.body : _options$parent,
          _options$context = options.context,
          context = _options$context === void 0 ? createStore() : _options$context,
          clear = options.clear,
          owner = options.owner;

      if (options.sync) {
        if (clear) {
          _from(parent.childNodes).forEach(function (childNode) {
            parent.removeChild(childNode);
          });
        }

        parent.appendChild(toFrag(toNodes(src, context, parent, owner)));
      } else {
        renderCallbacks.push(function () {
          render(src, {
            parent: parent,
            owner: owner,
            context: context,
            clear: clear,
            sync: true
          });
        });
        reqTick();
      }
    };

    var noCmpProps = ['children'];
    function patch(node, hNode, curProps, oldProps, curPropKeys) {
      var curProp, oldProp;
      curPropKeys.forEach(function (key) {
        curProp = curProps[key];
        oldProp = oldProps[key];

        if (noCmpProps.includes(key) || !HUI.cmp(curProp, oldProp)) {
          handleProp(node, hNode, key, curProp, oldProp);
        }
      });
    }

    var clear = function clear(hNode) {
      var desc = hNode.desc,
          output = hNode.output;
      hNode.active = false;

      if (desc) {
        if (desc.clear) {
          try {
            desc.clear.call(hNode, hNode.props, hNode.store, hNode.context);
          } catch (err) {
            _console.error(err);
          }
        }
      } else {
        var ref = hNode.props.ref;

        if (ref) {
          ref();
        }
      }

      var index = expired.indexOf(hNode);

      if (~index) {
        expired.splice(index, 1);
      }

      if (output) {
        output.forEach(function (child) {
          if (isHNode(child)) {
            clear(child);
          }
        });
      }
    };

    var updateChildren = function updateChildren(element, hNode, newChildren, oldChildren) {
      var childNodes = element.childNodes,
          oldChildrenCount = oldChildren.length;
      var nodeOffset = 0,
          oldProps,
          oldNodes,
          newChild,
          newNodes,
          newProps,
          newPropKeys;
      oldChildren.forEach(function (oldChild, i) {
        newChild = newChildren[i];

        if (newChild) {
          if (isHNode(oldChild)) {
            oldNodes = oldChild.nodes;

            if (isHNode(newChild) && newChild.type === oldChild.type) {
              newNodes = oldNodes;

              if (oldChild.desc) {
                inherit(newChild, oldChild);
                nodeOffset += newNodes.length;
                return mark(newChild);
              } else {
                newPropKeys = _keys(newProps = newChild.props);

                if (_keys(oldProps = oldChild.props).every(function (key) {
                  return newPropKeys.includes(key);
                })) {
                  inherit(newChild, oldChild);
                  nodeOffset++;
                  return patch(newNodes[0], newChild, newProps, oldProps, newPropKeys);
                }
              }
            }

            clear(oldChild);
          } else if (HUI.cmp(oldChild, newChild)) {
            return nodeOffset++;
          } else {
            oldNodes = childNodes.length ? [childNodes[nodeOffset]] : [];
          }

          nodeOffset += (newNodes = toNodes(newChild, hNode.context, element, hNode)).length;

          if (oldNodes.length) {
            replaceNodes(element, oldNodes, newNodes);
          } else {
            element.appendChild(toFrag(newNodes));
          }
        } else {
          if (isHNode(oldChild)) {
            clear(oldChild);
            oldChild.nodes.forEach(function (node) {
              element.removeChild(node);
            });
          } else if (childNodes.length) {
            element.removeChild(childNodes[nodeOffset++]);
          }
        }
      });

      if (oldChildrenCount < newChildren.length) {
        render(newChildren.slice(oldChildrenCount), {
          parent: element,
          owner: hNode,
          context: hNode.context
        });
      }
    };

    var propHandlers = new _Map([['children', function (element, newChildren, oldChildren, hNode) {
      updateChildren(element, hNode, newChildren, oldChildren || []);
    }], ['style', function (element, style) {
      if (style && _typeof(style) === 'object') {
        _assign(element.style, style);
      } else {
        try {
          element.style = style;
        } catch (_unused) {
          element.setAttribute('style', style);
        }
      }
    }], ['class', function (element, classes) {
      element.setAttribute('class', _isArray(classes) ? classes.filter(_Boolean).join(' ') : classes);
    }], ['ref', function (element, callback) {
      callback(element);
    }], ['attr', function (element, attributes) {
      _keys(attributes).forEach(function (key) {
        element.setAttribute(key, attributes[key]);
      });
    }], ['prop', function (element, properties) {
      _assign(element, properties);
    }]]);

    var LISTENER_PREFIX = 'on';
    var CAPTURE = 'Captrue',
        NONPASSIVE = 'Nonpassive',
        ONCE = 'Once';
    var listen = function listen(node, event, listener) {
      var capture = false,
          passive = true,
          once = false;

      for (var i = 0; i < 3; i++) {
        if (event.endsWith(CAPTURE)) {
          capture = true;
          event = event.slice(0, -7);
        } else if (event.endsWith(NONPASSIVE)) {
          passive = false;
          event = event.slice(0, -10);
        } else if (event.endsWith(ONCE)) {
          once = true;
          event = event.slice(0, -4);
        }
      }

      var options = (capture || !passive || once) && {
        capture: capture,
        passive: passive,
        once: once
      };
      node.addEventListener(event, listener, options);
      return [event, listener, options];
    };

    var handleProp = function handleProp(element, hNode, key, newValue, oldValue) {
      var handler = propHandlers.get(key);

      if (handler) {
        handler(element, newValue, oldValue, hNode);
      } else {
        if (key.startsWith(LISTENER_PREFIX)) {
          var events = hNode.events,
              record = events.get(key);

          if (record) {
            element.removeEventListener(record[0], record[1], record[2]);
          }

          events.set(key, listen(element, key.slice(2), newValue));
        } else if (key in element) {
          try {
            element[key] = newValue;
          } catch (_unused) {
            element.setAttribute(key, newValue);
          }
        } else {
          element.setAttribute(key, newValue);
        }
      }
    };

    var handleError = function handleError(err, hNode) {
      var owner = hNode.owner,
          desc;

      if (owner) {
        while (!((desc = owner.desc) && desc.catch) && owner.owner) {
          owner = owner.owner;
        }

        owner.error = err;
        mark(owner);
      } else {
        throw err;
      }
    };

    var toNodes = function toNodes(src, context, ownerNode, owner) {
      var srcType = _typeof(src);

      if (srcType === 'string') {
        return [_document.createTextNode(src)];
      } else if (srcType === 'number') {
        return [_document.createTextNode(String(src))];
      }

      if (src) {
        if (_isArray(src) && src.length) {
          return src.flat(_Infinity).map(function (s) {
            return toNodes(s, context, ownerNode, owner);
          }).flat();
        } else if (isHNode(src)) {
          var type = src.type,
              desc = src.desc,
              props = src.props;
          src.ownerNode = ownerNode;
          src.owner = owner;

          if (desc) {
            var store = src.store = createStore();

            if (desc.state) {
              src.store.bind(src, desc.state);
            }

            src.context = context;

            if (desc.context) {
              context.bind(src, desc.context);
            }

            try {
              src.active = false;

              if (desc.init) {
                desc.init.call(src, props, store, context);
              }

              return src.nodes = toNodes(src.output = toArr(desc.render.call(src, props, store, context)).flat(_Infinity), context, ownerNode, src);
            } catch (err) {
              if (desc.catch) {
                return src.nodes = toNodes(src.output = toArr(desc.catch.call(src, err, props, store, context)).flat(_Infinity), context, ownerNode, src);
              } else {
                handleError(err, src);
              }
            } finally {
              src.active = true;
            }
          } else {
            src.events = new _Map();
            var node = props.xmlns ? _document.createElementNS(props.xmlns, type) : _document.createElement(type);

            _keys(props).forEach(function (key) {
              handleProp(node, src, key, props[key]);
            });

            src.output = [];
            src.nodes = [node];
            return [node];
          }
        }
      }

      return [_document.createTextNode('')];
    };

    var updateComponent = function updateComponent(hNode) {
      var desc = hNode.desc,
          output = hNode.output,
          nodes = hNode.nodes,
          owner = hNode.owner,
          ownerNode = hNode.ownerNode,
          context = hNode.context,
          props = hNode.props,
          store = hNode.store,
          error = hNode.error,
          outputLength = output.length,
          ownerNodes = owner && owner.nodes;
      var newNodes = [].concat(nodes);

      try {
        hNode.active = false;

        if (error) {
          hNode.error = _undefined;
          throw error;
        }

        var ownerNodeNodes = ownerNode.childNodes;
        var old,
            oldProps,
            oldNodes,
            oldNodesLength,
            curNodes,
            curProps,
            curPropKeys,
            nodeOffset = 0,
            nextNode;
        (hNode.output = toArr(desc.render.call(hNode, props, store, context)).flat(_Infinity)).forEach(function (cur, i) {
          if (i < outputLength) {
            old = output[i];
            oldNodesLength = 1;

            if (isHNode(old)) {
              oldNodesLength = (oldNodes = old.nodes).length;

              if (isHNode(cur) && old.type === cur.type) {
                if (old.desc) {
                  inherit(cur, old);
                  mark(cur);
                  nodeOffset += cur.nodes.length;
                  return;
                } else {
                  curPropKeys = _keys(curProps = cur.props);

                  if (_keys(oldProps = old.props).every(function (k) {
                    return curPropKeys.includes(k);
                  })) {
                    nodeOffset++;
                    inherit(cur, old);
                    return patch(oldNodes[0], cur, curProps, oldProps, curPropKeys);
                  }
                }
              }

              clear(old);
            } else if (!isHNode(cur) && HUI.cmp(old, cur)) {
              return;
            }

            curNodes = toNodes(cur, context, ownerNode, hNode);
            oldNodes = _splice.apply(newNodes, [newNodes.indexOf(nodes[nodeOffset]), oldNodesLength].concat(curNodes));
            nodeOffset += oldNodesLength;
            replaceNodes(ownerNode, oldNodes, curNodes);
          } else {
            if (i === outputLength) {
              nextNode = ownerNodeNodes[_indexOf.call(ownerNodeNodes, newNodes[newNodes.length - 1]) + 1] || _null;
            }

            _push.apply(newNodes, curNodes = toNodes(cur, context, ownerNode, hNode));

            ownerNode.insertBefore(toFrag(curNodes), nextNode);
          }
        });
      } catch (err) {
        if (desc.catch) {
          newNodes = toNodes(hNode.output = toArr(desc.catch.call(hNode, err, props, store, context)), context, ownerNode, hNode);
          replaceNodes(ownerNode, nodes, newNodes);
          output.forEach(function (child) {
            if (isHNode(child)) {
              clear(child);
            }
          });
        } else {
          handleError(err, hNode);
        }
      } finally {
        hNode.active = true;
      }

      if (ownerNodes) {
        var firstNode = nodes[0],
            restArgs = [nodes.length].concat(newNodes);
        var target = owner,
            targetNodes = ownerNodes;

        while (target) {
          targetNodes = target.nodes;

          _splice.apply(targetNodes, [targetNodes.indexOf(firstNode)].concat(restArgs));

          target = target.owner;
        }
      }

      hNode.nodes = newNodes;
    };

    var expired = new Array();
    var deferCallbacks = new Array(),
        preDeferCallbacks = new Array();
    var willTick = false;

    var ticker = function ticker() {
      willTick = false;
      var deadline = Date.now() + HUI.frameLimit;
      var cur, i;

      for (i = 0; i < expired.length; i++) {
        cur = expired[i];

        if (!cur) {
          continue;
        }

        expired[i] = _undefined;

        try {
          updateComponent(cur);
        } catch (err) {
          expired.splice(0, i + 1);
          throw err;
        }

        if (Date.now() >= deadline) {
          expired.splice(0, i + 1);
          return tick();
        }
      }

      expired.length = 0;

      for (i = 0; i < preDeferCallbacks.length; i++) {
        preDeferCallbacks[i]();

        if (Date.now() >= deadline) {
          preDeferCallbacks.splice(0, i + 1);
          return tick();
        }
      }

      preDeferCallbacks.length = 0;

      for (i = 0; i < renderCallbacks.length; i++) {
        renderCallbacks[i]();

        if (Date.now() >= deadline) {
          renderCallbacks.splice(0, i + 1);
          return tick();
        }
      }

      renderCallbacks.length = 0;

      for (i = 0; i < deferCallbacks.length; i++) {
        deferCallbacks[i]();

        if (Date.now() >= deadline) {
          deferCallbacks.splice(0, i + 1);
          return tick();
        }
      }

      deferCallbacks.length = 0;
    };

    var tick = function tick() {
      HUI.tick(ticker);
      willTick = true;
    };

    var reqTick = function reqTick() {
      if (!willTick) {
        tick();
      }
    };
    var mark = function mark(hNode) {
      if (!expired.includes(hNode)) {
        reqTick();
        expired.push(hNode);
      }
    };
    var defer = function defer(callback) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      deferCallbacks.push(function () {
        callback.apply(void 0, args);
      });
      reqTick();
    };

    var createStore = function createStore() {
      var map = new _Map(),
          bindingMap = new _Map(),
          setterMap = new _Map();
      var store = {
        map: map,
        bind: function bind(hNode, subscriptions) {
          subscriptions.forEach(function (key) {
            if (bindingMap.has(key)) {
              bindingMap.get(key).push(hNode);
            } else {
              bindingMap.set(key, [hNode]);
            }
          });
          return this;
        },
        get: function store_get(key) {
          return map.get(key);
        },
        set: function store_set(key, value, force) {
          if (force || !HUI.cmp(value, store.get(key))) {
            map.set(key, value);

            if (bindingMap.has(key)) {
              bindingMap.get(key).forEach(function (hNode) {
                if (hNode.active) {
                  mark(hNode);
                }
              });
            }
          }

          return store;
        },
        setter: function store_setter(key, force) {
          var index = +!force;

          if (setterMap.has(key)) {
            var setters = setterMap.get(key),
                setter = setters[index];

            if (setter) {
              return setter;
            } else {
              return setters[index] = function setter(value) {
                store.set(key, value, force);
              };
            }
          } else {
            var _setters = new Array();

            setterMap.set(key, _setters);
            return _setters[index] = function setter(value) {
              store.set(key, value, force);
            };
          }
        },
        toggle: function store_toggle(key) {
          return store.set(key, !store.get(key));
        },
        inc: function store_inc(key) {
          var addition = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
          return store.set(key, store.get(key) + addition);
        },
        push: function store_push(key) {
          for (var _len = arguments.length, items = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            items[_key - 1] = arguments[_key];
          }

          return store.set(key, store.get(key).concat(items));
        },
        unshift: function store_unshift(key) {
          for (var _len2 = arguments.length, items = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
            items[_key2 - 1] = arguments[_key2];
          }

          return store.set(key, items.concat(store.get(key)));
        },
        slice: function store_slice(key, start, end) {
          return store.set(key, store.get(key).slice(start, end));
        },
        splice: function store_splice(key, start, deleteCount) {
          var arr = store.get(key).slice();

          for (var _len3 = arguments.length, items = new Array(_len3 > 3 ? _len3 - 3 : 0), _key3 = 3; _key3 < _len3; _key3++) {
            items[_key3 - 3] = arguments[_key3];
          }

          _splice.apply(arr, [start, deleteCount].concat(items));

          return store.set(key, arr);
        }
      };
      return store;
    };

    var portalSymbol = define('HUI.Portal', {
      init: function portal_init(props, store) {
        store.set('parent', props.parent || _document.body);
        store.set('fragment', HUI(HUI.Fragment, _null, props.children));
      },
      render: function portal_render(props, store, context) {
        render(store.get('fragment'), {
          parent: store.get('parent'),
          owner: this,
          context: context
        });
      },
      clear: function portal_clear(props, store) {
        var fragment = store.get('fragment'),
            ownerNode = fragment.ownerNode,
            nodes = fragment.nodes;
        clear(fragment);
        nodes.forEach(function (node) {
          ownerNode.removeChild(node);
        });
        nodes.length = 0;
      }
    });

    var contextSymbol = define('HUI.Context', {
      init: function context_init(props, store, context) {
        context.set(props.key, props.value);
      },
      render: function context_render(props) {
        return props.children;
      }
    });

    var cmp = function cmp(a, b) {
      if (_is(a, b)) {
        return true;
      }

      if (_isArray(a)) {
        return _isArray(b) && a.length === b.length && a.every(function (v, i) {
          return cmp(b[i], v);
        });
      }

      if (a && b && _typeof(a) === 'object' && _typeof(b) === 'object') {
        if (a.isHNode) {
          return b.isHNode && a.type === b.type && cmp(a.props, b.props);
        } else if (!(a instanceof _Node || b instanceof _Node)) {
          var keysA = _keys(a),
              keysB = _keys(b);

          return keysA.length === keysB.length && keysA.every(function (k) {
            return keysB.includes(k) && cmp(a[k], b[k]);
          });
        }
      }

      return false;
    };

    var fragmentSymbol = define('HUI.Fragment', {
      render: function fragment_render(props) {
        return props.children;
      }
    });

    var HUI = function HUI(type, props) {
      for (var _len = arguments.length, children = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
        children[_key - 2] = arguments[_key];
      }

      return {
        isHNode: true,
        type: type,
        desc: registry.get(type),
        props: _assign({
          children: children.flat(_Infinity)
        }, props),
        active: true
      };
    };
    HUI.registry = registry;
    HUI.define = define;
    HUI.createStore = createStore;
    HUI.propHandlers = propHandlers;
    HUI.noCmpProps = noCmpProps;
    HUI.render = render;

    HUI.tick = function (callback) {
      requestAnimationFrame(callback);
    };

    HUI.frameLimit = 15;
    HUI.defer = defer;
    HUI.Portal = portalSymbol;
    HUI.Context = contextSymbol;
    HUI.Fragment = fragmentSymbol;
    HUI.cmp = cmp;

    return HUI;

}));
